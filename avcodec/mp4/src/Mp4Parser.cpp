#include <arpa/inet.h>#include <sys/times.h>#include <unistd.h>#include <errno.h>#include <time.h>#include <string.h>#include <stdlib.h>#include <stdio.h>#include "mp4v2/mp4v2.h"#include "Mp4Parser.h"using namespace std;#define MP4_MAX_SAMPLE_LEN  512<<10#define MP4_MAX_SPS_LEN  256#define MP4_MAX_PPS_LEN  256#define H264_NALHDR_LEN    4#ifndef UINT64_C#define UINT64_C(x)  x ## ULL#endifvoid mpSleep(uint32_t ms) {       usleep(ms * 1000);}  unsigned long mpClkRateGet() {    long ret = sysconf(_SC_CLK_TCK);        return (unsigned long)ret;}  unsigned long mpTickGet() {    clock_t ret = times(NULL);    //times always valid!    if (-1 == ret) {            ret = 0xffffffff - errno;    }     return (unsigned long)ret;}  unsigned long mpTickToMs(unsigned long dwTick) {    return dwTick * (1000 / mpClkRateGet());}CMp4File::CMp4File(CMp4FileCallBack * pcCallBack, string pInFile): m_pcCallBack(pcCallBack), m_pInFile(pInFile), m_dwVideoTrackID(0), m_dwAudioTrackID(0), m_pHandle(NULL), m_wSPSLen(0), m_pchSPS(NULL), m_wPPSLen(0), m_pchPPS(NULL), m_pchVideoWriteSample(NULL), m_pchAudioWriteSample(NULL), m_ucAudioChanNum(0), m_ucAudioType(0), m_ucAudioFrequencies(0){    char *pMP4FileInfo = MP4FileInfo(m_pInFile.c_str());    if (pMP4FileInfo != NULL) {        printf("Get mp4 file info: \n%s\n", pMP4FileInfo);        free(pMP4FileInfo);    }    m_pchSPS = new u_char[MP4_MAX_SPS_LEN];    m_pchPPS = new u_char[MP4_MAX_PPS_LEN];    m_pchVideoWriteSample = new u_char[MP4_MAX_SAMPLE_LEN];    m_pchAudioWriteSample = new u_char[MP4_MAX_SAMPLE_LEN];}CMp4File::~CMp4File(){    if (m_pchSPS) {        delete[]m_pchSPS;        m_pchSPS = NULL;    }    if (m_pchPPS) {        delete[]m_pchPPS;        m_pchPPS = NULL;    }    if (m_pchVideoWriteSample) {        delete[]m_pchVideoWriteSample;        m_pchVideoWriteSample = NULL;    }    if (m_pchAudioWriteSample) {        delete[]m_pchAudioWriteSample;        m_pchAudioWriteSample = NULL;    }    if (NULL != m_pHandle) {        MP4Close((void *)m_pHandle);        m_pHandle = NULL;    }}void CMp4File::ParseTrackId(){    uint32_t dwNumTracks = MP4GetNumberOfTracks(m_pHandle);    for (uint32_t i = 0; i < dwNumTracks; i++) {        const char *media_data_name = NULL;        uint32_t dwTrackId = MP4FindTrackId(m_pHandle, i);        const char *pchTrackType = MP4GetTrackType(m_pHandle, dwTrackId);        if (pchTrackType == NULL) {            continue;        }        if (!strcmp(pchTrackType, MP4_VIDEO_TRACK_TYPE)) {            media_data_name = MP4GetTrackMediaDataName(m_pHandle, dwTrackId);            if (media_data_name == NULL) {                continue;            }            if (0 == strcmp(media_data_name, "avc1")) {                m_dwVideoTrackID = dwTrackId;            }        }        if (!strcmp(pchTrackType, MP4_AUDIO_TRACK_TYPE)) {            media_data_name = MP4GetTrackMediaDataName(m_pHandle, dwTrackId);            if (media_data_name == NULL) {                continue;            }            if (0 == strcmp(media_data_name, "mp4a")) {                m_dwAudioTrackID = dwTrackId;            }        }        printf("track id: %d, track type: %s, media data name: %s\n", dwTrackId, pchTrackType, media_data_name);    }    return;}uint16_t CMp4File::StartParse(){    m_pHandle = MP4Read(m_pInFile.c_str());    if (!m_pHandle) {        return MP4PARSER_ERROR_READFILE;    }    ParseTrackId();    ThreadProcMain();    return MP4PARSER_NO_ERROR;}uint16_t CMp4File::StopParse(){    if (NULL != m_pHandle) {        MP4Close((void *)m_pHandle);        m_pHandle = NULL;    }    return MP4PARSER_NO_ERROR;}bool CMp4File::GetH264Param(u_char *pchSPS, uint16_t wMaxSPSLen, uint16_t *pwRealSPSLen,                            u_char *pchPPS, uint16_t wMaxPPSLen, uint16_t *pwRealPPSLen){    u_char nalheader[H264_NALHDR_LEN] = {0x00, 0x00, 0x00, 0x01};    u_char **seqheader, **pictheader;    uint32_t *pictheadersize, *seqheadersize;    uint32_t ix;    bool res = MP4GetTrackH264SeqPictHeaders(m_pHandle, m_dwVideoTrackID, &seqheader, &seqheadersize,                                                 &pictheader, &pictheadersize);    if (false == res) {        return false;    }    for (ix = 0; seqheadersize[ix] != 0; ix++) {        uint16_t size = (seqheadersize[ix] < (wMaxSPSLen - H264_NALHDR_LEN))         						? (seqheadersize[ix]) : (wMaxSPSLen - H264_NALHDR_LEN);        memcpy(pchSPS, nalheader, H264_NALHDR_LEN);        memcpy(pchSPS + H264_NALHDR_LEN, seqheader[ix], size);        (*pwRealSPSLen) = H264_NALHDR_LEN + size;        free(seqheader[ix]);    }    free(seqheader);    free(seqheadersize);    for (ix = 0; pictheadersize[ix] != 0; ix++) {        uint16_t size = (pictheadersize[ix] < wMaxPPSLen - H264_NALHDR_LEN)         						? (pictheadersize[ix]) : wMaxPPSLen - H264_NALHDR_LEN;        memcpy(pchPPS, nalheader, H264_NALHDR_LEN);        memcpy(pchPPS + H264_NALHDR_LEN, pictheader[ix], size);        (*pwRealPPSLen) = H264_NALHDR_LEN + size;        free(pictheader[ix]);    }    free(pictheader);    free(pictheadersize);    return true;}bool CMp4File::ProcessVideoSamples(unsigned long dwStartMs, uint32_t dwVideoId, uint32_t *pdwNextVideoId){    memset(m_pchVideoWriteSample, 0, MP4_MAX_SAMPLE_LEN);    u_char *pSample = NULL;    uint32_t sampleSize = 0;    unsigned long long msectime = 0;    MP4Timestamp sampleTime;    MP4Duration sampleDuration;    uint32_t timescale = MP4GetTrackTimeScale(m_pHandle, m_dwVideoTrackID);    u_char *pchTempPtr = m_pchVideoWriteSample;    uint32_t dwWriteSampleSize = 0;    uint32_t sampleId = dwVideoId + 1;    bool bReadRet = MP4ReadSample(m_pHandle, m_dwVideoTrackID, sampleId, &pSample,                      &sampleSize, &sampleTime, &sampleDuration);    if ((false == bReadRet) || (sampleSize < 5)            || (sampleSize > MP4_MAX_SAMPLE_LEN) || (NULL == pSample)) {        return false;    }    msectime = sampleTime;    msectime *= UINT64_C(1000);    msectime /= timescale;    unsigned long dwCurTick = mpTickGet();    unsigned long dwCurMs = mpTickToMs(dwCurTick);    if ((dwCurMs - dwStartMs) >= msectime) {        bool bGotFirstIDR = false;        u_char *pFirstIDR = NULL;        for (uint16_t i = 0; i < sampleSize;) {            uint32_t *pSize = (uint32_t *)(pSample + i);            uint32_t wSize = ntohl(*pSize);            pSample[i] = 0x00;            pSample[i + 1] = 0x00;            pSample[i + 2] = 0x00;            pSample[i + 3] = 0x01;            if ((5 == (pSample[i + 4] & 0x1f)) && (false == bGotFirstIDR)) {                pFirstIDR = pSample + i;                bGotFirstIDR = true;            }            i += wSize + 4;        }        if (NULL != pFirstIDR) {            uint32_t dwSpanSize = pFirstIDR - pSample;            if (0 != dwSpanSize) {                memcpy(pchTempPtr, pSample, dwSpanSize);                pchTempPtr += dwSpanSize;            }            memcpy(pchTempPtr, m_pchSPS, m_wSPSLen);            pchTempPtr += m_wSPSLen;            memcpy(pchTempPtr, m_pchPPS, m_wPPSLen);            pchTempPtr += m_wPPSLen;            memcpy(pchTempPtr, pFirstIDR, (sampleSize - dwSpanSize));            pchTempPtr += (sampleSize - dwSpanSize);            dwWriteSampleSize = pchTempPtr - m_pchVideoWriteSample;            if (m_pcCallBack) {                m_pcCallBack->OnVideoCallBack(this,  m_pchVideoWriteSample + dwSpanSize,                                              (dwWriteSampleSize - dwSpanSize), true);            }        } else {            memcpy(m_pchVideoWriteSample, pSample, sampleSize);            dwWriteSampleSize = sampleSize;            if (m_pcCallBack) {                m_pcCallBack->OnVideoCallBack(this, pSample, sampleSize, false);            }        }        (*pdwNextVideoId) = ++dwVideoId;    } else {        printf("[VID id=%d] NOT callback startms:%u, curms:%lu, diff:%lu, msectime:%lu \n",             sampleId, dwStartMs, dwCurMs, (dwCurMs-dwStartMs), msectime);        (*pdwNextVideoId) = dwVideoId;    }    free(pSample);    pSample = NULL;    return true;}bool CMp4File::ConstructAudioHeader(u_char *pHdr, u_char ucProfile, u_char ucFreqIdx,                                    u_char ucChanCfg, uint16_t wPacketLen){    if ((NULL == pHdr) || (0 == wPacketLen)) {        return false;    }    pHdr[0] = (u_char)0xFF;    pHdr[1] = (u_char)0xF1;    pHdr[2] = (u_char)(((ucProfile - 1) << 6) + (ucFreqIdx << 2) + (ucChanCfg >> 2));    pHdr[3] = (u_char)(((ucChanCfg & 3) << 6) + (wPacketLen >> 11));    pHdr[4] = (u_char)((wPacketLen & 0x7FF) >> 3);    pHdr[5] = (u_char)(((wPacketLen & 7) << 5) + 0x1F);    pHdr[6] = (u_char)0xFC;    return true;}bool CMp4File::ProcessAudioSamples(unsigned long dwStartMs, uint32_t dwAudioId, uint32_t *pdwNextAudioId){    memset(m_pchAudioWriteSample, 0, MP4_MAX_SAMPLE_LEN);    u_char *pSample = NULL;    uint32_t sampleSize = 0;    unsigned long long msectime = 0;    MP4Timestamp sampleTime;    MP4Duration sampleDuration;    uint32_t timescale = MP4GetTrackTimeScale(m_pHandle, m_dwAudioTrackID);    u_char *pchTempPtr = m_pchAudioWriteSample;    uint32_t dwWriteSampleSize = 0;    uint32_t sampleId = dwAudioId + 1;    bool bReadRet = MP4ReadSample(m_pHandle, m_dwAudioTrackID, sampleId, &pSample,                      &sampleSize, &sampleTime, &sampleDuration);    if ((false == bReadRet) || (sampleSize < 5)            || (sampleSize > MP4_MAX_SAMPLE_LEN) || (NULL == pSample)) {        return false;    }    msectime = sampleTime;    msectime *= UINT64_C(1000);    msectime /= timescale;    unsigned long dwCurTick = mpTickGet();    unsigned long dwCurMs = mpTickToMs(dwCurTick);    if ((dwCurMs - dwStartMs) >= msectime) {        printf("[AUD id=%d]callback startms:%u, curms:%lu, diff:%lu, msectime:%llu \n",             sampleId, dwStartMs, dwCurMs, (dwCurMs-dwStartMs), msectime);        u_char achAudioHeader[MP4_AUDIO_ADTSHDR_LEN];        memset(achAudioHeader, 0, MP4_AUDIO_ADTSHDR_LEN);        bool bCreateHdr = ConstructAudioHeader(achAudioHeader, m_ucAudioType,                                 m_ucAudioFrequencies, m_ucAudioChanNum,                                 sampleSize + MP4_AUDIO_ADTSHDR_LEN);        if (false == bCreateHdr) {            printf("[ERROR] Failed to Construct Audio ADTS Header \n");            return false;        }        memcpy(m_pchAudioWriteSample, achAudioHeader, MP4_AUDIO_ADTSHDR_LEN);        dwWriteSampleSize += MP4_AUDIO_ADTSHDR_LEN;        memcpy(m_pchAudioWriteSample + MP4_AUDIO_ADTSHDR_LEN, pSample, sampleSize);        dwWriteSampleSize += sampleSize;        if (m_pcCallBack) {            m_pcCallBack->OnAudioCallBack(this, m_pchAudioWriteSample, dwWriteSampleSize);        }        (*pdwNextAudioId) = ++dwAudioId;    } else {        printf("[AUD id=%d] NOT callback startms:%u, curms:%lu, diff:%lu, msectime:%llu \n",                     sampleId, dwStartMs, dwCurMs, (dwCurMs-dwStartMs), msectime );        (*pdwNextAudioId) = dwAudioId;    }    free(pSample);    pSample = NULL;    return true;}void CMp4File::ThreadProcMain(void){    bool res = GetH264Param(m_pchSPS, MP4_MAX_SPS_LEN, &m_wSPSLen, m_pchPPS, MP4_MAX_PPS_LEN, &m_wPPSLen);    if (false == res) {        return;    }    u_char *pchAudioESConfig = NULL;    uint32_t dwAudioESConfigSize = 0;    bool bGetES = MP4GetTrackESConfiguration(m_pHandle, m_dwAudioTrackID, &pchAudioESConfig, &dwAudioESConfigSize);    if ((false == bGetES) || (dwAudioESConfigSize < 1)            || (NULL == pchAudioESConfig)) {        if (dwAudioESConfigSize < 1) {            free(pchAudioESConfig);        }        return;    }    m_ucAudioType = ((pchAudioESConfig[0] >> 3) & 0x1f);    m_ucAudioFrequencies = ((pchAudioESConfig[0] & 0x07) << 1) | ((pchAudioESConfig[1] & 0x80) >> 7);    m_ucAudioChanNum = ((pchAudioESConfig[1] >> 3) & 0x0f);    printf("[AUD] m_ucAudioType:%u m_ucAudioFrequencies:%u m_ucAudioChanNum:%u\n", m_ucAudioType, m_ucAudioFrequencies, m_ucAudioChanNum );    free(pchAudioESConfig);    MP4SampleId dwNumVideoSamples = MP4GetTrackNumberOfSamples(m_pHandle, m_dwVideoTrackID);    MP4SampleId dwNumAudioSamples = MP4GetTrackNumberOfSamples(m_pHandle, m_dwAudioTrackID);    printf("VideoTrackID:%u, dwNumVideoSamples:%u starttick:%lu\n", m_dwVideoTrackID, dwNumVideoSamples, mpTickGet());    printf("AudioTrackID:%u, dwNumAudioSamples:%u starttick:%lu\n", m_dwAudioTrackID, dwNumAudioSamples, mpTickGet());    uint32_t dwVideoId = 0;    uint32_t dwAudioId = 0;    unsigned long dwStartTick = mpTickGet();    unsigned long dwStartMs = mpTickToMs(dwStartTick);    while (1) {        if ((dwVideoId >= dwNumVideoSamples) && (dwAudioId >= dwNumAudioSamples)) {            break;        }        bool bVideoProceed = false;        if (dwVideoId < dwNumVideoSamples) {            uint32_t dwNextVideoId;            bool bRet = ProcessVideoSamples(dwStartMs, dwVideoId, &dwNextVideoId);            if (false == bRet) {                break;            }            if (dwVideoId != dwNextVideoId) {                dwVideoId = dwNextVideoId;                bVideoProceed = true;            }        }        bool bAudioProceed = false;        if (dwAudioId < dwNumAudioSamples) {            uint32_t dwNextAudioId;            bool bRet = ProcessAudioSamples(dwStartMs, dwAudioId, &dwNextAudioId);            if (false == bRet) {                break;            }            if (dwAudioId != dwNextAudioId) {                dwAudioId = dwNextAudioId;                bAudioProceed = true;            }        }        if ((false == bVideoProceed) && (false == bAudioProceed)) {            mpSleep(5);            continue;        }    }    printf("VideoTrackID:%u, dwNumVideoSamples:%u dwVideoId:%u stoptick:%lu \n",            m_dwVideoTrackID, dwNumVideoSamples, dwVideoId, mpTickGet());    printf("AudioTrackID:%u, dwNumAudioSamples:%u dwAudioId:%u stoptick:%lu \n",            m_dwAudioTrackID, dwNumAudioSamples, dwAudioId, mpTickGet());}