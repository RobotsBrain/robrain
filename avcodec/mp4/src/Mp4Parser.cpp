#include <arpa/inet.h>#include <sys/times.h>#include <unistd.h>#include <errno.h>#include <time.h>#include <string.h>#include <stdlib.h>#include <stdio.h>#include "mp4v2/mp4v2.h"#include "Mp4Parser.h"using namespace std;#define MP4_AUDIO_ADTSHDR_LEN   7#define H264_NALHDR_LEN         4#ifndef UINT64_C#define UINT64_C(x)  x ## ULL#endif unsigned long mpClkRateGet() {    long ret = sysconf(_SC_CLK_TCK);        return (unsigned long)ret;}  unsigned long mpTickGet() {    clock_t ret = times(NULL);    //times always valid!    if (-1 == ret) {            ret = 0xffffffff - errno;    }     return (unsigned long)ret;}  unsigned long mpTickToMs(unsigned long dwTick) {    return dwTick * (1000 / mpClkRateGet());}CMp4Parser::CMp4Parser(CMp4ParserCallBack * pcCallBack, string pInFile): m_pcCallBack(pcCallBack), m_pInFile(pInFile), m_dwVideoTrackID(0), m_dwAudioTrackID(0), m_pHandle(NULL), m_wSPSLen(0), m_pchSPS(NULL), m_wPPSLen(0), m_pchPPS(NULL), m_ucAudioChanNum(0), m_ucAudioType(0), m_ucAudioFrequencies(0){    char *pMP4FileInfo = MP4FileInfo(m_pInFile.c_str());    if (pMP4FileInfo != NULL) {        printf("Get mp4 file info: \n%s\n", pMP4FileInfo);        free(pMP4FileInfo);    }}CMp4Parser::~CMp4Parser(){    Stop();}void CMp4Parser::ParseTrackId(){    uint32_t dwNumTracks = MP4GetNumberOfTracks(m_pHandle);    for (uint32_t i = 0; i < dwNumTracks; i++) {        const char *media_data_name = NULL;        uint32_t dwTrackId = MP4FindTrackId(m_pHandle, i);        const char *pchTrackType = MP4GetTrackType(m_pHandle, dwTrackId);        if (pchTrackType == NULL) {            continue;        }        if (!strcmp(pchTrackType, MP4_VIDEO_TRACK_TYPE)) {            media_data_name = MP4GetTrackMediaDataName(m_pHandle, dwTrackId);            if (media_data_name == NULL) {                continue;            }            if (0 == strcmp(media_data_name, "avc1")) {                m_dwVideoTrackID = dwTrackId;            }        }        if (!strcmp(pchTrackType, MP4_AUDIO_TRACK_TYPE)) {            media_data_name = MP4GetTrackMediaDataName(m_pHandle, dwTrackId);            if (media_data_name == NULL) {                continue;            }            if (0 == strcmp(media_data_name, "mp4a")) {                m_dwAudioTrackID = dwTrackId;            }        }        printf("track id: %d, track type: %s, media data name: %s\n", dwTrackId, pchTrackType, media_data_name);    }    return;}bool CMp4Parser::Start(){    m_pHandle = MP4Read(m_pInFile.c_str());    if (!m_pHandle) {        return false;    }    ParseTrackId();    Analysis();    return true;}bool CMp4Parser::Stop(){    if (m_pchSPS) {        delete[] m_pchSPS;        m_pchSPS = NULL;    }    if (m_pchPPS) {        delete[] m_pchPPS;        m_pchPPS = NULL;    }    if (NULL != m_pHandle) {        MP4Close((void *)m_pHandle);        m_pHandle = NULL;    }    return true;}bool CMp4Parser::GetH264Param(){    u_char nalheader[H264_NALHDR_LEN] = {0x00, 0x00, 0x00, 0x01};    u_char **seqheader, **pictheader;    uint32_t *pictheadersize, *seqheadersize;    uint32_t ix;    int offset = 0;    bool res = MP4GetTrackH264SeqPictHeaders(m_pHandle, m_dwVideoTrackID, &seqheader, &seqheadersize,                                                 &pictheader, &pictheadersize);    if (false == res) {        return false;    }    for (ix = 0; seqheadersize[ix] != 0; ix++) {        m_wSPSLen += H264_NALHDR_LEN + seqheadersize[ix];    }    m_pchSPS = new u_char[m_wSPSLen];    for (ix = 0; seqheadersize[ix] != 0; ix++) {        memcpy(m_pchSPS + offset, nalheader, H264_NALHDR_LEN);        memcpy(m_pchSPS + offset + H264_NALHDR_LEN, seqheader[ix], seqheadersize[ix]);        offset += H264_NALHDR_LEN + seqheadersize[ix];        free(seqheader[ix]);    }    free(seqheader);    free(seqheadersize);    for (ix = 0; pictheadersize[ix] != 0; ix++) {        m_wPPSLen += H264_NALHDR_LEN + pictheadersize[ix];    }    m_pchPPS = new u_char[m_wPPSLen];    offset = 0;    for (ix = 0; pictheadersize[ix] != 0; ix++) {        memcpy(m_pchPPS + offset, nalheader, H264_NALHDR_LEN);        memcpy(m_pchPPS + offset + H264_NALHDR_LEN, pictheader[ix], pictheadersize[ix]);        offset += H264_NALHDR_LEN + pictheadersize[ix];        free(pictheader[ix]);    }    free(pictheader);    free(pictheadersize);    return true;}bool CMp4Parser::GetAacParam(){    u_char *pchAudioESConfig = NULL;    uint32_t dwAudioESConfigSize = 0;    bool bGetES = MP4GetTrackESConfiguration(m_pHandle, m_dwAudioTrackID, &pchAudioESConfig, &dwAudioESConfigSize);    if ((false == bGetES) || (dwAudioESConfigSize < 1)            || (NULL == pchAudioESConfig)) {        if (dwAudioESConfigSize < 1) {            free(pchAudioESConfig);        }        return false;    }    m_ucAudioType = ((pchAudioESConfig[0] >> 3) & 0x1f);    m_ucAudioFrequencies = ((pchAudioESConfig[0] & 0x07) << 1) | ((pchAudioESConfig[1] & 0x80) >> 7);    m_ucAudioChanNum = ((pchAudioESConfig[1] >> 3) & 0x0f);    free(pchAudioESConfig);    printf("[AUD] type: %u Frequencies: %u ChanNum: %u\n", m_ucAudioType, m_ucAudioFrequencies, m_ucAudioChanNum);    return true;}bool CMp4Parser::ProcessVideoSamples(unsigned long dwStartMs, uint32_t &dwVideoId){    u_char *pSample = NULL;    uint32_t sampleSize = 0;    unsigned long long msectime = 0;    MP4Timestamp sampleTime;    MP4Duration sampleDuration;    uint32_t timescale = MP4GetTrackTimeScale(m_pHandle, m_dwVideoTrackID);    uint32_t sampleId = dwVideoId + 1;    bool res = MP4ReadSample(m_pHandle, m_dwVideoTrackID, sampleId, &pSample,                                &sampleSize, &sampleTime, &sampleDuration);    if ((false == res) || (sampleSize < 5) || (NULL == pSample)) {        return false;    }    msectime = (sampleTime * UINT64_C(1000)) / timescale;    unsigned long dwCurTick = mpTickGet();    unsigned long dwCurMs = mpTickToMs(dwCurTick);    if ((dwCurMs - dwStartMs) >= msectime) {        bool bGotFirstIDR = false;        u_char *pFirstIDR = NULL;        for (uint16_t i = 0; i < sampleSize;) {            uint32_t *pSize = (uint32_t *)(pSample + i);            uint32_t wSize = ntohl(*pSize);            pSample[i] = 0x00;            pSample[i + 1] = 0x00;            pSample[i + 2] = 0x00;            pSample[i + 3] = 0x01;            if ((5 == (pSample[i + 4] & 0x1f)) && (false == bGotFirstIDR)) {                pFirstIDR = pSample + i;                bGotFirstIDR = true;            }            i += wSize + 4;        }        if (NULL != pFirstIDR) {            uint32_t dwSpanSize = pFirstIDR - pSample;            if (m_pcCallBack) {                // printf("[VID id=%d] callback startms:%u, curms:%lu, diff:%lu, msectime:%lu\n",                 //             sampleId, dwStartMs, dwCurMs, (dwCurMs - dwStartMs), msectime);                m_pcCallBack->OnVideoCallBack(this, m_pchSPS, m_wSPSLen, false);                m_pcCallBack->OnVideoCallBack(this, m_pchPPS, m_wPPSLen, false);                m_pcCallBack->OnVideoCallBack(this, pFirstIDR, sampleSize - dwSpanSize, true);            }        } else {            if (m_pcCallBack) {                m_pcCallBack->OnVideoCallBack(this, pSample, sampleSize, false);            }        }        ++dwVideoId;    } else {        // printf("[VID id=%d] NOT callback startms:%u, curms:%lu, diff:%lu, msectime:%lu\n",         //     sampleId, dwStartMs, dwCurMs, (dwCurMs - dwStartMs), msectime);    }    free(pSample);    pSample = NULL;    return true;}bool CMp4Parser::ConstructAudioHeader(u_char *pHdr, u_char ucProfile, u_char ucFreqIdx,                                    u_char ucChanCfg, uint16_t wPacketLen){    pHdr[0] = (u_char)0xFF;    pHdr[1] = (u_char)0xF1;    pHdr[2] = (u_char)(((ucProfile - 1) << 6) + (ucFreqIdx << 2) + (ucChanCfg >> 2));    pHdr[3] = (u_char)(((ucChanCfg & 3) << 6) + (wPacketLen >> 11));    pHdr[4] = (u_char)((wPacketLen & 0x7FF) >> 3);    pHdr[5] = (u_char)(((wPacketLen & 7) << 5) + 0x1F);    pHdr[6] = (u_char)0xFC;    return true;}bool CMp4Parser::ProcessAudioSamples(unsigned long dwStartMs, uint32_t &dwAudioId){    u_char *pSample = NULL;    uint32_t sampleSize = 0;    unsigned long long msectime = 0;    MP4Timestamp sampleTime;    MP4Duration sampleDuration;    uint32_t timescale = MP4GetTrackTimeScale(m_pHandle, m_dwAudioTrackID);    uint32_t sampleId = dwAudioId + 1;    bool res = MP4ReadSample(m_pHandle, m_dwAudioTrackID, sampleId, &pSample,                                &sampleSize, &sampleTime, &sampleDuration);    if ((false == res) || (sampleSize < 5) || (NULL == pSample)) {        return false;    }    msectime = (sampleTime * UINT64_C(1000)) / timescale;    unsigned long dwCurTick = mpTickGet();    unsigned long dwCurMs = mpTickToMs(dwCurTick);    if ((dwCurMs - dwStartMs) >= msectime) {        // printf("[AUD id=%d]callback startms:%u, curms:%lu, diff:%lu, msectime:%llu\n",         //         sampleId, dwStartMs, dwCurMs, (dwCurMs - dwStartMs), msectime);        u_char achAudioHeader[MP4_AUDIO_ADTSHDR_LEN];        memset(achAudioHeader, 0, MP4_AUDIO_ADTSHDR_LEN);        bool bCreateHdr = ConstructAudioHeader(achAudioHeader, m_ucAudioType, m_ucAudioFrequencies,                                                 m_ucAudioChanNum, sampleSize + MP4_AUDIO_ADTSHDR_LEN);        if (false == bCreateHdr) {            printf("[ERROR] Failed to Construct Audio ADTS Header \n");            return false;        }        if (m_pcCallBack) {            m_pcCallBack->OnAudioCallBack(this, achAudioHeader, MP4_AUDIO_ADTSHDR_LEN, pSample, sampleSize);        }        ++dwAudioId;    } else {        // printf("[AUD id=%d] NOT callback startms:%u, curms:%lu, diff:%lu, msectime:%llu\n",         //             sampleId, dwStartMs, dwCurMs, (dwCurMs - dwStartMs), msectime );    }    free(pSample);    pSample = NULL;    return true;}void CMp4Parser::Analysis(){    uint32_t dwVideoId = 0;    uint32_t dwAudioId = 0;    unsigned long dwStartTick = mpTickGet();    unsigned long dwStartMs = mpTickToMs(dwStartTick);    if(GetH264Param() == false) {        return;    }    if(GetAacParam() == false) {        return;    }    MP4SampleId dwNumVideoSamples = MP4GetTrackNumberOfSamples(m_pHandle, m_dwVideoTrackID);    MP4SampleId dwNumAudioSamples = MP4GetTrackNumberOfSamples(m_pHandle, m_dwAudioTrackID);    printf("NumVideoSamples:%u NumAudioSamples:%u starttick:%lu\n", dwNumVideoSamples, dwNumAudioSamples, mpTickGet());    while (1) {        if ((dwVideoId >= dwNumVideoSamples) && (dwAudioId >= dwNumAudioSamples)) {            break;        }        if (dwVideoId < dwNumVideoSamples) {            if(ProcessVideoSamples(dwStartMs, dwVideoId) == false) {                break;            }        }        if (dwAudioId < dwNumAudioSamples) {            if(ProcessAudioSamples(dwStartMs, dwAudioId) == false) {                break;            }        }    }    printf("dwVideoId:%u audioid: %u, stoptick:%lu \n", dwVideoId, dwAudioId, mpTickGet());    return;}